<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flood Yearly Statistics</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<div class="container mt-5">
    <h1 class="text-center">Flood Yearly Statistics</h1>
    <div class="d-flex mb-3">
        <select id="dataSet" class="form-select w-auto">
            <option value="hanza">HANZA Dataset</option>
            <option value="dartmouth">Dartmouth Flood Observatory</option>
        </select>
        <select id="timeLapse" class="form-select w-auto ms-3">
            <option value="1">1 Year</option>
            <option value="5">5 Years</option>
            <option value="10">10 Years</option>
            <option value="15">15 Years</option>
            <option value="20">20 Years</option>
        </select>
        <select id="countryFilter" class="form-select w-auto ms-3">
            <option value="all">All Countries</option>
        </select>
        <div class="form-check ms-3">
            <input class="form-check-input" type="radio" name="chartDataOption" id="optionOccurrences" value="occurrences" checked>
            <label class="form-check-label" for="optionOccurrences">
                Count of Occurrences
            </label>
        </div>
        <div class="form-check ms-3">
            <input class="form-check-input" type="radio" name="chartDataOption" id="optionFatalities" value="totalFatalities">
            <label class="form-check-label" for="optionFatalities">
                Total Fatalities
            </label>
        </div>
        <div class="form-check ms-3">
            <input class="form-check-input" type="radio" name="chartDataOption" id="optionPersonsAffected" value="totalPersonsAffected">
            <label class="form-check-label" for="optionPersonsAffected">
                Total Persons Affected
            </label>
        </div>
        <div class="form-check ms-3">
            <input class="form-check-input" type="radio" name="chartDataOption" id="optionLosses" value="totalLosses">
            <label class="form-check-label" for="optionLosses">
                Total Losses
            </label>
        </div>
        <div class="form-check ms-3">
            <input class="form-check-input" type="checkbox" id="chartTypeToggle" value="alternate">
            <label class="form-check-label" for="chartTypeToggle">
                Use Pie Chart
            </label>
        </div>
    </div>
    <canvas id="floodChart" class="my-4"></canvas>
    <div id="statsTable" class="table-responsive small"></div>
</div>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<!-- PapaParse JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Custom JS -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        loadCountries();
        loadData();
        // Disable 'Total Losses' option initially if 'dartmouth' dataset is selected
        const isDartmouth = document.getElementById('dataSet').value === 'dartmouth';
        const lossesOption = document.getElementById('optionLosses');
        lossesOption.disabled = isDartmouth;
        if (isDartmouth && lossesOption.checked) {
            document.getElementById('optionOccurrences').checked = true;
        }
    });

    let parsedCSVData = null; // Store parsed CSV data
    let floodChartInstance = null;

    function loadCountries() {
        fetch('data/countries.csv')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.statusText}`);
                }
                return response.text();
            })
            .then(csvText => {
                // Parse the CSV using PapaParse
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function (results) {
                        if (results.errors.length) {
                            console.error("CSV Parsing Errors:", results.errors);
                        } else {
                            const countryFilter = document.getElementById('countryFilter');
                            results.data.forEach(row => {
                                if (row['Name'] && row['Code']) {
                                    const option = document.createElement('option');
                                    option.value = row['Code'];
                                    option.textContent = row['Name'];
                                    countryFilter.appendChild(option);
                                }
                            });
                        }
                    }
                });
            })
            .catch(error => {
                console.error('Error loading the countries CSV file:', error);
            });
    }

    function loadData() {
        const selectedDataSet = document.getElementById('dataSet').value;
        let filePath = '';

        if (selectedDataSet === 'hanza') {
            filePath = 'data/hanza_11259233_Version_v2.1.2_events.csv';
        } else if (selectedDataSet === 'dartmouth') {
            filePath = 'data/dartmouth_flood_observatory_02_10_2024.csv';
        }

        fetch(filePath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.statusText}`);
                }
                return response.text();
            })
            .then(csvText => {
                // Parse the CSV using PapaParse
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function (results) {
                        if (results.errors.length) {
                            console.error("CSV Parsing Errors:", results.errors);
                        } else {
                            parsedCSVData = results.data;
                            processCSVData(parsedCSVData, selectedDataSet); // Process data after parsing
                        }
                    }
                });
            })
            .catch(error => {
                console.error('Error loading the CSV file:', error);
            });
    }

    function processCSVData(data, dataset) {
        const yearlyStats = {};
        const floodCounts = {};
        const selectedCountry = document.getElementById('countryFilter').value;
        const selectedCountryName = document.querySelector(`#countryFilter option[value="${selectedCountry}"]`).textContent;

        // Loop through data and aggregate by year
        data.forEach(row => {
            if (Object.values(row).every(val => val === '')) {
                return; // Skip empty line but do not end iteration
            }

            if (selectedCountry !== 'all'
                && row["Country code"] !== selectedCountry
                && row["Country"]?.replace(/"/g, '') !== selectedCountryName)
            {
                return; // Skip rows that do not match the selected country
            }

            let year;
            if (dataset === 'hanza') {
                year = parseInt(row["Year"]);
            } else if (dataset === 'dartmouth') {
                year = parseInt(row["Began"].substring(0, 4));
            }

            if (!isNaN(year)) {
                if (!yearlyStats[year]) {
                    yearlyStats[year] = {
                        totalFatalities: 0,
                        totalPersonsAffected: 0,
                        totalLosses: 0,
                        records: []
                    };
                    floodCounts[year] = 0;
                }

                if (dataset === 'hanza') {
                    yearlyStats[year].totalFatalities += parseInt(row["Fatalities"]) || 0;
                    yearlyStats[year].totalPersonsAffected += parseInt(row["Persons affected"]) || 0;
                    yearlyStats[year].totalLosses += parseFloat(row["Losses (2020 euro)"]) || 0;
                    floodCounts[year] += 1; // Count each flood
                } else if (dataset === 'dartmouth') {
                    yearlyStats[year].totalFatalities += parseInt(row["Dead"]) || 0;
                    yearlyStats[year].totalPersonsAffected += parseInt(row["Displaced"]) || 0;
                    floodCounts[year] += 1; // Count each flood
                }
                yearlyStats[year].records.push(row);
            }
        });

        // Render chart with the processed flood data
        renderFloodChart(yearlyStats, floodCounts);
    }

    function renderFloodChart(yearlyStats, floodCounts) {
        const ctx = document.getElementById('floodChart').getContext('2d');
        const timeLapse = parseInt(document.getElementById('timeLapse').value);
        const selectedOption = document.querySelector('input[name="chartDataOption"]:checked').value;
        const usePieChart = document.getElementById('chartTypeToggle').checked;
        let dataToPlot = {};

        if (selectedOption === 'occurrences') {
            dataToPlot = groupByTimeLapse(floodCounts, timeLapse);
        } else {
            dataToPlot = groupByTimeLapse(yearlyStats, timeLapse, selectedOption);
        }

        // Get sorted years and counts to match
        const years = Object.keys(dataToPlot).sort((a, b) => a - b);
        const counts = years.map(year => dataToPlot[year]);

        // Destroy the previous chart instance if it exists
        if (floodChartInstance) {
            floodChartInstance.destroy();
        }

        // Determine chart type based on checkbox
        const chartType = usePieChart ? 'pie' : 'bar';

        // Create a new chart instance
        floodChartInstance = new Chart(ctx, {
            type: chartType,
            data: {
                labels: years,
                datasets: [{
                    label: `${selectedOption.charAt(0).toUpperCase() + selectedOption.slice(1)} (Grouped by ${timeLapse} Year(s))`,
                    data: counts,
                    backgroundColor: usePieChart ? years.map(() => `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.6)`) : 'rgba(75, 192, 192, 0.6)',
                    borderColor: usePieChart ? years.map(() => `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 1)`) : 'rgba(75, 192, 192, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                scales: usePieChart ? {} : {
                    x: {
                        beginAtZero: true
                    },
                    y: {
                        beginAtZero: true
                    }
                },
                onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const elementIndex = elements[0].index;
                        const selectedYear = years[elementIndex];
                        const yearStart = parseInt(selectedYear);
                        const yearEnd = yearStart + timeLapse - 1;
                        const records = Object.values(yearlyStats).flatMap(stat => {
                            const year = parseInt(stat.records[0]?.Year || stat.records[0]?.Began?.substring(0, 4));
                            return (year >= yearStart && year <= yearEnd) ? stat.records : [];
                        });
                        const yearRange = `${yearStart} - ${yearEnd}`;
                        displayRecords(records, yearRange);
                    }
                }
            }
        });
    }

    function groupByTimeLapse(data, timeLapse, key = null) {
        const groupedData = {};
        const years = Object.keys(data).map(year => parseInt(year)).sort((a, b) => a - b);

        years.forEach(year => {
            const groupYear = Math.floor(year / timeLapse) * timeLapse;
            if (!groupedData[groupYear]) {
                groupedData[groupYear] = 0;
            }
            groupedData[groupYear] += key ? (data[year][key] || 0) : data[year];
        });

        return groupedData;
    }

    function displayRecords(records, yearRange) {
        const statsTable = document.getElementById('statsTable');
        statsTable.innerHTML = `<h5 class="mt-4 text-center">Detailed Records (Count: ${records.length}, Year Range: ${yearRange})</h5><table class="table table-striped table-sm mt-3"><thead class="table-light"><tr>` +
            Object.keys(records[0]).map(key => `<th class="sortable" data-key="${key}">${key}</th>`).join('') +
            '</tr></thead><tbody>' +
            records.map(record => '<tr>' +
                Object.values(record).map(value => `<td>${value}</td>`).join('') +
                '</tr>').join('') +
            '</tbody></table>';

        // Add click event listener to table headers for sorting
        document.querySelectorAll('.sortable').forEach(header => {
            header.addEventListener('click', function () {
                const key = this.getAttribute('data-key');
                const sortedRecords = [...records].sort((a, b) => {
                    let aValue = a[key];
                    let bValue = b[key];

                    if (key === "Start date" || key === "End date") {
                        aValue = new Date(aValue);
                        bValue = new Date(bValue);
                    } else {
                        aValue = isNaN(aValue) ? aValue : parseFloat(aValue);
                        bValue = isNaN(bValue) ? bValue : parseFloat(bValue);
                    }

                    if (aValue < bValue) return -1;
                    if (aValue > bValue) return 1;

                    // make NaN always less
                    if (isNaN(aValue) && isNaN(bValue)) return 0;
                    if (isNaN(aValue)) return -1;
                    if (isNaN(bValue)) return 1;
                    return 0;
                });

                // Toggle sorting direction
                if (this.classList.contains('asc')) {
                    sortedRecords.reverse();
                    this.classList.remove('asc');
                    this.classList.add('desc');
                } else {
                    this.classList.remove('desc');
                    this.classList.add('asc');
                }

                // Update the table body with sorted records
                const tbody = statsTable.querySelector('tbody');
                tbody.innerHTML = sortedRecords.map(record => '<tr>' +
                    Object.values(record).map(value => `<td>${value}</td>`).join('') +
                    '</tr>').join('');
            });
        });
    }

    // Update the chart when the time lapse selection, data option, dataset, or country filter changes
    document.getElementById('timeLapse').addEventListener('change', function () {
        if (parsedCSVData) {
            processCSVData(parsedCSVData, document.getElementById('dataSet').value); // Use already parsed CSV data for faster processing
        }
    });

    document.getElementById('dataSet').addEventListener('change', function () {
        loadData();
        // Disable 'Total Losses' option if 'dartmouth' dataset is selected
        const isDartmouth = document.getElementById('dataSet').value === 'dartmouth';
        const lossesOption = document.getElementById('optionLosses');
        lossesOption.disabled = isDartmouth;
        if (isDartmouth && lossesOption.checked) {
            document.getElementById('optionOccurrences').checked = true;
        }
    });

    document.getElementById('countryFilter').addEventListener('change', function () {
        if (parsedCSVData) {
            processCSVData(parsedCSVData, document.getElementById('dataSet').value); // Use already parsed CSV data for faster processing
        }
    });

    document.querySelectorAll('input[name="chartDataOption"]').forEach(radio => {
        radio.addEventListener('change', function () {
            if (parsedCSVData) {
                processCSVData(parsedCSVData, document.getElementById('dataSet').value); // Use already parsed CSV data for faster processing
            }
        });
    });

    document.getElementById('chartTypeToggle').addEventListener('change', function () {
        if (parsedCSVData) {
            processCSVData(parsedCSVData, document.getElementById('dataSet').value); // Update chart with new type
        }
    });
</script>
</body>
</html>
